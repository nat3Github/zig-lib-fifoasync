/// Autogenerated, will refresh if underlying struct changes and build.zig if setup in the build script
/// changes to this file will likely be overwritten

const std = @import("std");

const src = @import("example.zig");

pub fn NewStruct(comptime Server: type) type {
if (!(@hasDecl(Server, "send"))) {
@compileError("the server type is missing the send method");
}
return struct {
    channel: Server,
    const Type = src.example.MyStruct;
pub fn message_handler(remote: *src.example.MyStruct, msg: NewStructArgs) NewStructRet {
switch (msg) {
NewStructDecls.nothing =>  {
    return NewStructRet{.nothing = src.example.MyStruct.nothing() };
},
NewStructDecls.something => |v| {
    return NewStructRet{.something = src.example.MyStruct.something(v[0], v[1]) };
},
NewStructDecls.selfFunction => |v| {
    return NewStructRet{.selfFunction = src.example.MyStruct.selfFunction(remote, v[0], v[1]) };
},
NewStructDecls.kkkk => |v| {
    return NewStructRet{.kkkk = src.example.MyStruct.kkkk(remote, v[0], v[1]) };
}
}
}
// delegated functions:
pub fn nothing(self: *@This()) !void {
const msg = NewStructArgs{
.nothing = .{} 
};
try self.channel.send(msg);
}
pub fn something(self: *@This(), x0: i32, x1: f32) !void {
const msg = NewStructArgs{
.something = .{x0, x1} 
};
try self.channel.send(msg);
}
pub fn selfFunction(self: *@This(), x0: *src.example.MyStruct) !void {
const msg = NewStructArgs{
.selfFunction = .{x0} 
};
try self.channel.send(msg);
}
pub fn kkkk(self: *@This(), x0: *src.example.MyStruct) !void {
const msg = NewStructArgs{
.kkkk = .{x0} 
};
try self.channel.send(msg);
}
};
}

pub const NewStructDecls = enum {
nothing,
something,
selfFunction,
kkkk
};

pub const NewStructArgs = union(NewStructDecls) {
nothing: std.meta.tuple(&.{}),
something: std.meta.tuple(&.{i32, f32}),
selfFunction: std.meta.tuple(&.{*src.example.MyStruct}),
kkkk: std.meta.tuple(&.{*src.example.MyStruct})
};

pub const NewStructRet = union(NewStructDecls) {
nothing: f32,
something: void,
selfFunction: void,
kkkk: void
};